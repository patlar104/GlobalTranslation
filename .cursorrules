# Cursor AI Rules for GlobalTranslation Android App

## Project Context
This is a **PRODUCTION-READY** Android translation app built with Jetpack Compose and ML Kit. **Phase 2 (Camera Translation) now complete!** The codebase follows Android best practices for 2025.

## Core Technologies (Verified)
- **Build**: AGP 8.13.0, Kotlin 2.2.20, KSP 2.2.20-2.0.2, Hilt 2.57.2
- **Architecture**: MVVM with StateFlow, Hilt DI, Jetpack Compose
- **UI**: Material3 Expressive Theme (lavender/purple palette, large corner radii)
- **Translation**: ML Kit Translate API with offline model management
- **Camera**: CameraX 1.3.1 with ML Kit Text Recognition for OCR
- **Min/Target SDK**: 29/36, JVM Target: 11

## Critical Build Rules

### 1. Plugin Configuration (REQUIRED)
```kotlin
// In app/build.gradle.kts - ALL plugins must be present:
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)     // REQUIRED! Not optional
    alias(libs.plugins.kotlin.compose)     // Compose compiler
    alias(libs.plugins.ksp)                // For Hilt annotation processing
    alias(libs.plugins.hilt)               // Hilt DI
}
```

### 2. JVM Target Alignment (CRITICAL)
```kotlin
// Both MUST be JVM 11 - mismatch causes build failure
compileOptions {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}
kotlin {
    compilerOptions {
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_11)
    }
}
// Note: Old kotlinOptions { jvmTarget = "11" } is deprecated
```

### 3. KSP Version Format (IMPORTANT)
- For Kotlin 2.2.20, use KSP `2.2.20-2.0.2` (NOT 1.0.x!)
- KSP versioning changed from `1.0.x` to `2.0.x` format
- Version must match: `<kotlin-version>-<ksp-version>`

## StateFlow Best Practices (ALL ViewModels Use This)

### ✅ CORRECT Pattern (Used Throughout App)
```kotlin
@HiltViewModel
class MyViewModel @Inject constructor(
    private val service: MyService
) : ViewModel() {
    // PRIVATE MutableStateFlow for internal updates
    private val _uiState = MutableStateFlow(MyUiState())
    // PUBLIC immutable StateFlow with .asStateFlow()
    val uiState: StateFlow<MyUiState> = _uiState.asStateFlow()
    
    fun updateState() {
        _uiState.value = _uiState.value.copy(/* updates */)
    }
    
    // Always clean up resources
    override fun onCleared() {
        super.onCleared()
        service.cleanup()
    }
}

data class MyUiState(
    val data: String = "",
    val isLoading: Boolean = false,
    val error: String? = null
)
```

### ❌ WRONG Patterns to Avoid
```kotlin
// ❌ Don't expose MutableStateFlow directly
val uiState = MutableStateFlow(MyUiState())

// ❌ Don't use LiveData (use StateFlow instead)
val uiState: LiveData<MyUiState>

// ❌ Don't forget .asStateFlow()
val uiState: StateFlow<MyUiState> = _uiState  // Missing immutability

// ❌ Don't forget cleanup
// Missing onCleared() when using services
```

## Verified Project Structure

```
app/src/main/java/com/example/gloabtranslation/
├── GloabTranslationApplication.kt     # @HiltAndroidApp
├── MainActivity.kt                    # @AndroidEntryPoint + NavigationSuiteScaffold
├── model/
│   └── ConversationTurn.kt           # Data models
├── services/                         # All @Singleton + @Inject
│   ├── ServicesModule.kt             # Hilt DI module
│   ├── TranslationService.kt         # ML Kit translation
│   ├── SpeechRecognitionService.kt   # Speech recognition
│   ├── TextToSpeechService.kt        # TTS
│   ├── TextRecognitionService.kt     # ML Kit OCR ✅ NEW
│   └── CameraTranslationService.kt   # OCR + Translation ✅ NEW
├── ui/
│   ├── components/
│   │   └── LanguagePicker.kt         # Reusable components
│   ├── conversation/                 # Live voice translation
│   │   ├── ConversationScreen.kt
│   │   └── ConversationViewModel.kt  # @HiltViewModel + StateFlow
│   ├── textinput/                    # Manual text translation
│   │   ├── TextInputScreen.kt
│   │   └── TextInputViewModel.kt     # @HiltViewModel + StateFlow
│   ├── camera/                       # Camera translation ✅ NEW
│   │   ├── CameraScreen.kt           # Real-time OCR translation
│   │   └── CameraViewModel.kt        # @HiltViewModel + StateFlow
│   ├── languages/                    # Model management
│   │   ├── LanguageScreen.kt
│   │   └── LanguageViewModel.kt      # @HiltViewModel + StateFlow
│   └── theme/                        # Material3 Expressive Theme
│       ├── ExpressiveColors.kt       # Lavender/purple ✅ NEW
│       └── ExpressiveShapes.kt       # Large corner radii ✅ NEW
```

## Hilt Dependency Injection Rules

### Services (All Use This Pattern)
```kotlin
@Singleton
class MyService @Inject constructor() {
    // Service implementation
    
    fun cleanup() {
        // Clean up resources
    }
}
```

### ViewModels (All Use This Pattern)
```kotlin
@HiltViewModel
class MyViewModel @Inject constructor(
    private val service: MyService
) : ViewModel() {
    // StateFlow pattern here
}
```

### Application Class (Already Set Up)
```kotlin
@HiltAndroidApp
class GloabTranslationApplication : Application()
```

### Activities (Already Set Up)
```kotlin
@AndroidEntryPoint
class MainActivity : ComponentActivity()
```

## Compose UI Patterns

### Screen Composables
```kotlin
@Composable
fun MyScreen(
    modifier: Modifier = Modifier,
    viewModel: MyViewModel = hiltViewModel()  // Use hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()  // Collect StateFlow
    
    // UI based on uiState
}
```

### Component Composables
```kotlin
@Composable
fun MyComponent(
    data: String,
    onAction: () -> Unit,
    modifier: Modifier = Modifier
) {
    // Component implementation
    // Pass data down, callbacks up
}
```

## Code Quality Standards

### ✅ DO
- Use `viewModelScope` for all coroutines in ViewModels
- Implement `onCleared()` for resource cleanup
- Use immutable StateFlow exposure (`.asStateFlow()`)
- Use data classes for state objects
- Handle errors with nullable error strings in state
- Use `Result<T>` for service return types
- Keep services as `@Singleton`
- Use constructor injection with `@Inject`
- Follow Material3 design guidelines
- Use adaptive navigation (NavigationSuiteScaffold)

### ❌ DON'T
- Expose MutableStateFlow publicly
- Use LiveData (use StateFlow instead)
- Call services directly from Composables (use ViewModels)
- Forget to clean up resources in `onCleared()`
- Mix Kotlin versions (must match KSP version)
- Mismatch JVM targets (Java and Kotlin must both be 11)
- Add plugins without checking version catalog first
- Use deprecated APIs (project is Material3 throughout)

## When Making Changes

### Before Any Code Change:
1. ✅ Verify file exists and read its current content
2. ✅ Check if pattern matches existing code in project
3. ✅ Verify dependencies in `gradle/libs.versions.toml`
4. ✅ Ensure StateFlow pattern consistency
5. ✅ Check Hilt setup is correct

### After Code Changes:
1. ✅ Verify imports are valid
2. ✅ Check StateFlow pattern maintained
3. ✅ Ensure no circular dependencies
4. ✅ Verify Hilt annotations match pattern
5. ✅ Check resource cleanup if needed

## Common Issues & Solutions

### Issue: Plugin Not Found
**Error**: `Plugin [id: 'com.google.devtools.ksp'] was not found`
**Solution**: Verify KSP version is `2.2.20-2.0.2` in `gradle/libs.versions.toml`

### Issue: JVM Target Mismatch
**Error**: `Inconsistent JVM-target compatibility detected`
**Solution**: Ensure both `compileOptions` and `kotlinOptions` target JVM 11

### Issue: Hilt Compilation Failed
**Error**: `Hilt_* classes not generated`
**Solution**: 
1. Verify `kotlin.android` plugin is present
2. Clean and rebuild: `./gradlew clean build`
3. Check all Hilt annotations are correct

### Issue: ClassNotFoundException at Runtime
**Error**: `ClassNotFoundException: GloabTranslationApplication`
**Solution**: Ensure KSP is generating code - check all plugins are present

## Navigation Pattern

### AppDestinations Enum (Already Implemented)
```kotlin
enum class AppDestinations(val label: String, val icon: ImageVector) {
    CONVERSATION("Conversation", Icons.Filled.Mic),
    TEXT_INPUT("Text Input", Icons.Filled.Translate),
    LANGUAGES("Languages", Icons.Filled.Language),
}
```

### Navigation State Management
```kotlin
// In MainActivity/main composable
var currentDestination by rememberSaveable { mutableStateOf(AppDestinations.CONVERSATION) }

NavigationSuiteScaffold(
    navigationSuiteItems = {
        AppDestinations.entries.forEach { destination ->
            item(
                selected = it == currentDestination,
                onClick = { currentDestination = it },
                icon = { Icon(it.icon, it.label) },
                label = { Text(it.label) }
            )
        }
    }
) {
    when (currentDestination) {
        AppDestinations.CONVERSATION -> ConversationScreen()
        AppDestinations.TEXT_INPUT -> TextInputScreen()
        AppDestinations.LANGUAGES -> LanguageScreen()
    }
}
```

## ML Kit Translation Patterns

### Translation Service Pattern (Fully Implemented)
```kotlin
@Singleton
class TranslationService @Inject constructor() {
    private val activeTranslators = mutableMapOf<String, Translator>()
    
    // Translates text, auto-downloads models if needed (requires WiFi)
    suspend fun translate(
        text: String,
        fromLanguage: String,
        toLanguage: String
    ): Result<String> {
        return try {
            val translator = getOrCreateTranslator(fromLanguage, toLanguage)
            ensureModelDownloaded(translator)  // Downloads if needed
            val result = translator.translate(text).await()
            Result.success(result)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // IMPORTANT: Checks actual download status without triggering downloads
    suspend fun areModelsDownloaded(
        fromLanguage: String,
        toLanguage: String
    ): Boolean {
        return try {
            val modelManager = RemoteModelManager.getInstance()
            val fromModel = TranslateRemoteModel.Builder(fromLanguage).build()
            val toModel = TranslateRemoteModel.Builder(toLanguage).build()
            val fromDownloaded = modelManager.isModelDownloaded(fromModel).await()
            val toDownloaded = modelManager.isModelDownloaded(toModel).await()
            fromDownloaded && toDownloaded
        } catch (e: Exception) {
            false
        }
    }
    
    // Deletes a downloaded model from device storage
    suspend fun deleteModel(languageCode: String): Result<Unit> {
        return try {
            val modelManager = RemoteModelManager.getInstance()
            val model = TranslateRemoteModel.Builder(languageCode).build()
            modelManager.deleteDownloadedModel(model).await()
            
            // Clean up cached translators
            activeTranslators.entries.removeIf { (key, translator) ->
                if (key.contains(languageCode)) {
                    translator.close()
                    true
                } else false
            }
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    fun cleanup() {
        activeTranslators.values.forEach { it.close() }
        activeTranslators.clear()
    }
}
```

### Critical ML Kit Behaviors

**Model Download Requirements:**
- First-time downloads **require WiFi** (enforced by `DownloadConditions`)
- `translate()` auto-downloads models if not present
- `areModelsDownloaded()` checks status without downloading
- Languages screen uses `areModelsDownloaded()` for accurate status

**Error Handling:**
- Translation fails on cellular if models not downloaded
- Error messages should guide users to WiFi and Languages screen
- Always check download status before attempting translation on cellular

## Testing Patterns (For Future Implementation)

### ViewModel Testing
```kotlin
@ExtendWith(MockitoExtension::class)
class MyViewModelTest {
    @Mock private lateinit var service: MyService
    private lateinit var viewModel: MyViewModel
    
    @Test
    fun `state updates correctly`() = runTest {
        viewModel = MyViewModel(service)
        
        val states = mutableListOf<MyUiState>()
        backgroundScope.launch {
            viewModel.uiState.toList(states)
        }
        
        viewModel.performAction()
        
        // Verify state transitions
    }
}
```

## Performance Guidelines

### ✅ DO
- Use LazyColumn for lists (conversation history, language list)
- Use `remember` for computed values
- Use `derivedStateOf` for derived state
- Cache translators in TranslationService (already done)
- Use `viewModelScope` for automatic cancellation
- Implement proper cleanup in `onCleared()`

### ❌ DON'T
- Create new translators for each translation
- Forget to cancel ongoing operations
- Load large lists without lazy loading
- Create unnecessary recompositions

## Working with This Codebase

### The App is Complete
- ✅ All core features implemented and working
- ✅ All ViewModels follow StateFlow best practices
- ✅ All services properly injected with Hilt
- ✅ Build configuration stable and verified
- ✅ No deprecated API usage

### Future Enhancements (Optional)
When adding features, consider:
- Unit tests for ViewModels
- UI tests for user flows
- Room database for persistence
- Performance optimizations
- Enhanced accessibility

### Key Philosophy
- **Quality over quantity**: Code follows 2025 best practices
- **Simplicity first**: Clear, maintainable patterns throughout
- **Type safety**: Strong typing with StateFlow and data classes
- **Resource management**: Proper cleanup prevents memory leaks
- **User experience**: Modern Material3 with adaptive navigation

## Quick Reference

### Add New ViewModel
1. Create ViewModel with `@HiltViewModel` and `@Inject constructor`
2. Use StateFlow pattern (private MutableStateFlow + public StateFlow)
3. Implement `onCleared()` if using services
4. Create data class for state
5. Use `viewModelScope` for coroutines

### Add New Service
1. Create class with `@Singleton` and `@Inject constructor`
2. Add cleanup() method if needed
3. Return `Result<T>` or use Flow for reactive operations
4. Use suspend functions for async operations
5. Handle errors gracefully

### Add New Screen
1. Create Screen composable in appropriate ui/ package
2. Create ViewModel following StateFlow pattern
3. Add to AppDestinations enum if needed
4. Use `hiltViewModel()` in composable
5. Collect StateFlow with `collectAsState()`

## Additional Resources
- See `.github/instructions/copilot-instructions.md` for detailed patterns
- See `.github/instructions/copilot-analysis-rules.instructions.md` for debugging
- See `Project Plan.md` for implementation status
- See `README.md` for build setup and troubleshooting

